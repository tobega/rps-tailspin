use 'java:io.undertow' stand-alone
use 'java:io.undertow.server' stand-alone
use 'java:io.undertow.util' stand-alone

include 'json'

def moves: ['rock', 'paper', 'scissors'];
// returns an array containing the index of the input move,
// or an empty array if the input move was not found
templates findMoveIndex
  def move: $;
  $moves -> \[j](<=$move> $j !\) !
end findMoveIndex

templates getWinner
  def players: $;
  $ -> \[i]($.move -> findMoveIndex ... ! \)
    -> ($moves::length + $(1) - $(2)) mod $moves::length
    -> #
  when <=0> do
    'It''s a tie' !
  otherwise
    '$players($).name; wins' !
end getWinner

test 'rock, paper, scissors result'
  assert [$moves... -> [{name: 'A', move: $}, {name: 'B', move: $}] ->
    getWinner] <[<='It''s a tie'>+ VOID]> 'Same move is a tie'

  assert [1..$moves::length -> [{name: 'A', move: $moves($)}, {name: 'B', move: $moves($ mod $moves::length + 1)}] ->
    getWinner] <[<='B wins'>+ VOID]> 'One above wins'

  assert [1..$moves::length -> [{name: 'A', move: $moves($)}, {name: 'B', move: $moves(($+1) mod $moves::length + 1)}] ->
    getWinner] <[<='A wins'>+ VOID]> 'Two above loses'
end 'rock, paper, scissors result'

processor GameService
  @: [];
  source getStatus&{id:}
    templates describeStatus
      when <{players: <[<{move: <>}>=2]>}> do
        {id: $id, status: '$.players -> getWinner;', players: $.players, legalMoves: $moves} !
      when <{players: <[](1)>}> do
        {id: $id, status: '$.players(1).name; is waiting for an opponent', legalMoves: $moves} !
      otherwise
        $.players -> \[i](
          <~{move: <>}> $.name ! 'and' !
        \) -> $(1..last-1) -> {id: $id, status: 'Waiting for $... -> '$; ';to move', legalMoves: $moves} !
    end describeStatus
    $id -> #
    when <1..$@GameService::length>
      $@GameService($id) -> describeStatus !
    otherwise '' !
  end getStatus
  templates createGame
    when <~{name: <'.+'>}> do 'Please give a name' !
    when <{move: <?($ -> findMoveIndex <=[]>)>}> do
      '$.move; is not a recognized move. Please pick one of $moves;' !
    otherwise
      { players: [{name: $.name, $ -> \(<{move:<>}> $.move !\) -> (move: $)}]} -> ..|@GameService: $;
      $getStatus&{id:$@GameService::length}  !
  end createGame
  templates updateGame&{id:}
    when <?($id <1..$@GameService::length>)> do
      def game: $@GameService($id);
      $ -> \(
        when <?($game <{players: <[<{move: <>}>=2]>}>)> do
          'This game is already finished' !
        when <{move: <?($ -> findMoveIndex <=[]>)>}> do
          '$.move; is not a recognized move. Please pick one of $moves;' !
        when <~{name: <'.+'>}> do 'Please give a name' !
        when <{name: <=$game.players(1).name>}> do
          $ -> \(<{move:<>}> $.move !\) -> ..|@GameService($id).players(1): (move: $);
          $getStatus&{id: $id} !
        when <?($game.players <[](1)>)> do
          ..|@GameService($id).players: {name: $.name, $ -> \(<{move:<>}> $.move !\) -> (move: $)};
            $getStatus&{id: $id} !
        when <{name: <=$game.players(2).name>}> do
          $ -> \(<{move:<>}> $.move !\) -> ..|@GameService($id).players(2): (move: $);
          $getStatus&{id: $id} !
        otherwise 'The game is already full' !
      \) !
    otherwise '' !
  end updateGame
end GameService

def rpsService: $GameService;

sink sendResult&{exchange:}
  templates checkResult
    when <=''> do {statusCode: 404, body: ''} !
    when <'.*'> do {statusCode: 400, body: $} !
    otherwise {statusCode: 200, body: $} !
  end checkResult
  def result:$ -> checkResult;
  $result.statusCode -> exchange::setStatusCode -> !VOID
  def headers: $exchange::getResponseHeaders;
  ['Content-Type' -> util/HttpString, 'application/json'] -> headers::put -> !VOID
  def sender: $exchange::getResponseSender;
  $result.body -> json/serialize -> !sender::send
end sendResult

processor JsonPostCallback&{service:}
  sink handle
    def exchange: $(1);
    $(2) -> json/parse -> service -> !sendResult&{exchange: $exchange}
  end handle
end JsonPostCallback

templates getPathParameter&{exchange:}
  def pathParameters: $exchange::getQueryParameters;
  $ -> pathParameters::get -> $::iterator -> $::next !
end getPathParameter

composer toInt
  <INT>
end toInt

processor CreateGameHandler
  templates handleRequest
    def exchange: $;
    def receiver: $exchange::getRequestReceiver;
    $JsonPostCallback&{service: rpsService::createGame} -> !receiver::receiveFullString
  end handleRequest
end CreateGameHandler

processor GetGameStatusHandler
  templates handleRequest
    def exchange: $;
    def id: 'id' -> getPathParameter&{exchange: $exchange} -> toInt;
    $rpsService::getStatus&{id: $id} -> !sendResult&{exchange: $exchange}
  end handleRequest
end GetGameStatusHandler

processor UpdateGameHandler
  templates handleRequest
    def exchange: $;
    def id: 'id' -> getPathParameter&{exchange: $exchange} -> toInt;
    def receiver: $exchange::getRequestReceiver;
    $JsonPostCallback&{service: rpsService::updateGame&{id: $id}} -> !receiver::receiveFullString
  end handleRequest
end UpdateGameHandler

source createRpsHandlers
  def router: $server/RoutingHandler;
  ['/games', $CreateGameHandler] -> router::post -> !VOID
  ['/games/', $CreateGameHandler] -> router::post -> !VOID
  ['/games/{id}', $GetGameStatusHandler] -> router::get -> !VOID
  ['/games/{id}', $UpdateGameHandler] -> router::post -> !VOID
  $router !
end createRpsHandlers

source createServer&{port:,name:}
  def builder: $undertow/Undertow::builder;
  def b1: [$port, $name] -> builder::addHttpListener;
  def b2: $ -> b1::setHandler;
  $b2::build !
end createServer

def server: $createRpsHandlers -> createServer&{port: 8080, name: 'localhost'};
$server::start -> !VOID
